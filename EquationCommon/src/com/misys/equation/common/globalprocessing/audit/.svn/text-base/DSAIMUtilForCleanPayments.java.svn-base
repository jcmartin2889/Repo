package com.misys.equation.common.globalprocessing.audit;

import java.text.MessageFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.misys.equation.common.access.EquationStandardSession;
import com.misys.equation.common.dao.beans.APJRecordDataModel;
import com.misys.equation.common.dao.beans.APVRecordDataModel;
import com.misys.equation.common.internal.eapi.core.EQException;
import com.misys.equation.common.utilities.Toolbox;

/**
 * Provides utility methods for stripping out rules form a clean payments set DSAIM 'target' image that don't exist in the target
 * unit.
 * 
 * @author berzosa
 */
public class DSAIMUtilForCleanPayments
{
	// This attribute is used to store cvs version information.
	public static final String _revision = "$Id$";

	/** The APIs that this utility processes DSAIMs for */
	private static final List<String> APIS_TO_PROCESS = Arrays.asList(new String[] { "DPS", "DCH", "DHS", "DRP", "DAS" });

	/** Maps the parent set to member rule api identifier values */
	private static final Map<String, String> SET_TO_RULE_APIS = new HashMap<String, String>();

	/**
	 * Initialise the set to rules API identifiers
	 */
	static
	{
		SET_TO_RULE_APIS.put("DPS", "APR");
		SET_TO_RULE_APIS.put("DCH", "ACR");
		SET_TO_RULE_APIS.put("DHS", "AHO");
		SET_TO_RULE_APIS.put("DRP", "ARR");
		SET_TO_RULE_APIS.put("DAS", "AAC");
	}

	/**
	 * Returns true if the target DSAIM of the given API requires special processing.
	 * 
	 * @param apiIdentifier
	 *            The API identifier to check for
	 * @return true if target DSAIMs generated by SAPJ require special processing
	 */
	public static boolean requiresProcessing(String apiIdentifier)
	{
		return APIS_TO_PROCESS.contains(apiIdentifier);
	}

	/**
	 * Processes the DSAIM by removing GS parts that don't exist in the database for this clean payment set.
	 * 
	 * @param session
	 *            A session to use for calling SAPJ
	 * @param dsaim
	 *            The DSAIM generated by SAPJ containing GS repeating fields for verification
	 * @param gzlenb
	 *            The GZLength as returned by SAPJ
	 * @param apiIdentifier
	 *            The API Identifier to process the DSAIM of
	 * @param keyin
	 * @return a byte array containing the new DSAIM
	 */
	public static byte[] processDSAIM(EquationStandardSession session, byte[] dsaim, int gzlenb, String apiIdentifier, String keyin)
					throws EQException
	{
		final APVCacheUtil apvUtil = APVCacheUtil.getInstance(session);
		Integer gzLastPos = null, gsLength = null, gsqPosition = null;

		// determine the length of the GZ, GS, and position of GSSQ (Internal Sequence Number)
		for (APJRecordDataModel apj : apvUtil.findAPIFields(apiIdentifier))
		{
			final String apiFieldName = apj.getApiFieldName();
			if (apiFieldName.startsWith("GZ"))
			{
				// last GZ indicates the length of the GZ part
				gzLastPos = Integer.valueOf(apj.getApiFieldEnd());
			}
			else if (apiFieldName.startsWith("GS"))
			{
				// last GS indicates the length of the GS part
				gsLength = Integer.valueOf(apj.getApiFieldEnd());

				// is this the ' internal sequence number?
				if ("GSSQ".equals(apiFieldName))
				{
					// this is the position of the sequence number within the GS repeating block
					gsqPosition = Integer.valueOf(apj.getApiFieldStart());
				}
			}
		}

		if (gzLastPos == null || gsLength == null || gsqPosition == null)
		{
			throw new EQException("Unable to process DSAIM for: " + apiIdentifier + ".");
		}

		// prepare to call SAPJ on the rule API
		final String ruleAPI = SET_TO_RULE_APIS.get(apiIdentifier);
		final String ruleAPIFile = apvUtil.findAPVById(ruleAPI).getApiFileName();
		final Set<String> emptySet = new HashSet<String>();
		final String excludeFields = SAPJ10RUtils.prepareExcludeParams(apvUtil.findAPIFields(ruleAPI), emptySet, emptySet);

		// pad the set's key in parameter
		final APVRecordDataModel ruleApv = apvUtil.findAPVById(ruleAPI);

		// pad / truncate the set ID to leave exactly three characters for the sequence number
		final int keyLength;
		if ("ARR".equalsIgnoreCase(ruleAPI))
		{
			// data encoding error in APV, hard-code to 13
			keyLength = 13;
		}
		else
		{
			keyLength = Integer.parseInt(ruleApv.getApiKeyLength());
		}

		// prepare the prefix part of the key which includes the set ID
		final String setKeyIn = Toolbox.pad(keyin.trim(), keyLength - 3);

		// if the length changes, then we've processed stuff
		int newDSAIMLength = Math.min(dsaim.length, gzlenb);
		int currentGSPosition = gzLastPos;
		while (currentGSPosition < newDSAIMLength)
		{
			// get next record internal sequence number value
			final byte[] packedSQ = new byte[3];
			System.arraycopy(dsaim, currentGSPosition + gsqPosition - 1, packedSQ, 0, 3);

			final int sign = packedSQ[2] & 0x0F;
			if (sign != 0x0F)
			{
				// not a positive sign bit; this must be end of data!
				break;
			}

			// NOTE: 3 bytes constitutes 5 packed digits (6 nibbles - 1 nibble for the sign)
			final String sequenceNumber = MessageFormat.format("{0,number,000}", Toolbox.convertAS400Packed(packedSQ, 5, 0));

			// determine if this record exists
			if (!recordExists(session, ruleAPI, ruleAPIFile, setKeyIn + sequenceNumber, excludeFields))
			{
				// record does not exist! Shift all data to exclude this entry
				System.arraycopy(dsaim, currentGSPosition + gsLength, dsaim, currentGSPosition, newDSAIMLength
								- (currentGSPosition + gsLength));

				// adjust length of DSAIM by one repeating record
				newDSAIMLength -= gsLength;

				// continue on to next record at this offset
				continue;
			}

			// advance GS offset
			currentGSPosition += gsLength;
		}

		// truncate DSAIM if necessary
		if (newDSAIMLength == dsaim.length)
		{
			// no need to truncate / process DSAIM!
			return dsaim;
		}
		else
		{
			// DSAIM was processed! return truncated value
			final byte[] newDSAIM = new byte[newDSAIMLength];
			System.arraycopy(dsaim, 0, newDSAIM, 0, newDSAIMLength);
			return newDSAIM;
		}
	}
	/**
	 * Checks if the given clean payments rule exists by generating a 'before' image through SAPJ and determining if it returns a
	 * 'record found' value.
	 * 
	 * @param session
	 *            The session to use for calling SAPJ
	 * @param apiIdentifier
	 *            The API Identifier for the rule
	 * @param apifil
	 *            The API file for the rule (looked up in APVPF)
	 * @param keyin
	 *            The key to use (combination of the set key appended with the internal sequence number)
	 * @param excludeFields
	 *            The calculated fields to exclude (should all be '0')
	 * @return true if the clean payment rule record was found, false otherwise
	 * @throws EQException
	 *             If there was an error calling SAPJ
	 */
	private static boolean recordExists(EquationStandardSession session, String apiIdentifier, String apifil, String keyin,
					String excludeFields) throws EQException
	{
		// get the before image to see if the record exists on this unit
		final SAPJ10RDS record = SAPJ10RUtils.callStoredProcSAPJ10R(session, apiIdentifier, apifil, "B", session.getUnitId(),
						keyin, new byte[9999], excludeFields);

		// return true if record is valid and found
		return record.isValid() && record.isRecordFound();
	}
}
