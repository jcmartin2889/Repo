package com.misys.equation.function.runtime;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import com.misys.equation.common.internal.eapi.core.EQException;
import com.misys.equation.common.internal.eapi.core.EQMessage;
import com.misys.equation.common.utilities.EqBeanFactory;
import com.misys.equation.common.utilities.Toolbox;
import com.misys.equation.function.beans.RelatedFields;

/**
 * This class represents a list of messages
 * 
 */
public class FunctionMessages
{
	// This attribute is used to store cvs version information.
	public static final String _revision = "$Id: FunctionMessages.java 13462 2012-06-06 08:19:07Z bterrado $";

	// Message type
	// -1 - no message
	// 00 - information message
	// 10 - warning message
	// 20 - error message
	public final static int MSG_NONE = -1;
	public final static int MSG_INFO = 00;
	public final static int MSG_WARN = 10;
	public final static int MSG_ERROR = 20;
	private int msgSev;

	// List of messages
	private List<FunctionMessage> messages;
	private Map<String, FunctionMessage> allFunctionMessages;

	/**
	 * Construct a new empty list of messages
	 * 
	 */
	public FunctionMessages()
	{
		messages = new ArrayList<FunctionMessage>();
		clearMessages();
	}

	/**
	 * Returns the list of messages
	 * 
	 * @return the list of messages
	 */
	public List<FunctionMessage> getMessages()
	{
		return messages;
	}

	/**
	 * Returns the highest message severity
	 * 
	 * @return the message severity
	 */
	public int getMsgSev()
	{
		return msgSev;
	}

	/**
	 * Set the message severity
	 * 
	 * @param msgSev
	 *            - the message severity
	 */
	public void setMsgSev(int msgSev)
	{
		this.msgSev = msgSev;
	}

	/**
	 * Set the list of messages
	 * 
	 * @param messages
	 *            - list of messages
	 */
	public void addMessage(FunctionMessage message)
	{
		this.messages.add(message);
	}

	/**
	 * Set the list of messages
	 * 
	 * @param messages
	 *            - list of messages
	 */
	public void setMessages(ArrayList<FunctionMessage> messages)
	{
		this.messages = messages;
	}

	/**
	 * Clear messages
	 * 
	 */
	public void clearMessages()
	{
		this.msgSev = FunctionMessages.MSG_NONE;
		this.messages.clear();
	}

	/**
	 * Clear messages generated by the specified screen
	 * 
	 * @param screenSetId
	 *            - the screen set id
	 * @param scrnNo
	 *            - the screen number
	 * 
	 */
	public void clearMessages(int screenSetId, int scrnNo)
	{
		int i = 0;

		while (i < messages.size())
		{
			// same screen number, then remove it
			if (messages.get(i).getScreenSetId() == screenSetId && messages.get(i).getScrnNo() == scrnNo)
			{
				// do not increment the counter here, as the index of succeeding elements will be adjusted
				messages.remove(i);
			}

			// not the same, proceed to the next
			else
			{
				i++;
			}
		}
	}

	/**
	 * Clear messages generated from a specified screen up to the last screen
	 * 
	 * @param screenSetId
	 *            - the screen set id
	 * @param scrnNo
	 *            - the screen number
	 */
	public void clearHigherScreen(int screenSetId, int scrnNo)
	{
		int i = 0;

		while (i < messages.size())
		{
			// same screen number, then remove it
			FunctionMessage fm = messages.get(i);
			if (fm.getScreenSetId() > screenSetId || (fm.getScreenSetId() == screenSetId && fm.getScrnNo() >= scrnNo))
			{
				// do not increment the counter here, as the index of succeeding elements will be adjusted
				messages.remove(i);
			}

			// not the same, proceed to the next
			else
			{
				i++;
			}
		}
	}

	/**
	 * Is there no messages?
	 * 
	 * @return true if there are no messages
	 */
	public boolean chkNoMessage()
	{
		return (msgSev == MSG_NONE);
	}

	/**
	 * Return the list of messages in the format of 37 character
	 * 
	 * @return the list of messages in the format of 37 character
	 */

	public List<String> rtvDsepms()
	{
		ArrayList<String> msg = new ArrayList<String>();
		for (int i = 0; i < messages.size(); i++)
		{
			msg.add(messages.get(i).getEqMessage().getDsepms());
		}
		return msg;
	}

	/**
	 * Return the list of authorisor
	 * 
	 * @return the list of authorisor
	 */

	public List<String> rtvAuthorisor()
	{
		ArrayList<String> msg = new ArrayList<String>();
		for (int i = 0; i < messages.size(); i++)
		{
			msg.add(messages.get(i).getAuthorisor());
		}
		return msg;
	}

	/**
	 * Add to the list of messages using a message string
	 * 
	 * @param scrnNo
	 *            - the screen number where the message has been generated
	 * @param fieldName
	 *            - the field name that causes the message to be generated
	 * @param eqMessage
	 *            - the message
	 * @param firstLevelText
	 *            - text to be appended to the start of messageText
	 * @param secondLevelText
	 *            - text to be appended to the end of messageText
	 * 
	 * @return true - if the message has been added
	 */
	public FunctionMessage insertMessage(int screenSetId, int scrnNo, String fieldName, int sequence, EQMessage eqMessage,
					String firstLevelText, String secondLevelText)
	{
		// retrieve the message severity
		int sev = Toolbox.parseInt(eqMessage.getSeverity(), FunctionMessages.MSG_ERROR);

		// map this into Equation message severity
		int msev;
		if (sev >= 20)
		{
			msev = FunctionMessages.MSG_ERROR;
		}
		else if (sev >= 10)
		{
			msev = FunctionMessages.MSG_WARN;
		}
		else
		{
			msev = FunctionMessages.MSG_INFO;
		}

		// message to be added
		FunctionMessage functionMessage = null;
		if (msev >= msgSev)
		{
			functionMessage = new FunctionMessage(screenSetId, scrnNo, fieldName, sequence, eqMessage, firstLevelText,
							secondLevelText);
		}

		// the message severity is higher than the existing, then clear the messages and add this
		if (msev > msgSev)
		{
			clearMessages();
			msgSev = msev;
			messages.add(functionMessage);
		}

		// the message severity is the same as the existing, then add
		else if (msev == msgSev)
		{
			messages.add(functionMessage);
		}

		// added or not?
		return functionMessage;
	}

	/**
	 * Add the list of messages into the list of messages
	 * 
	 * @param messages
	 *            the list of messages
	 * 
	 * @return true - if the message has been added
	 */
	public boolean insertMessages(FunctionMessages messages)
	{
		List<FunctionMessage> msg = messages.getMessages();
		boolean added = false;
		for (int i = 0; i < msg.size(); i++)
		{
			FunctionMessage fm = msg.get(i);
			FunctionMessage fm1 = insertMessage(fm.getScreenSetId(), fm.getScrnNo(), fm.getFieldName(), fm.getSequence(), fm
							.getEqMessage(), fm.getFirstLevelText(), fm.getSecondLevelText());
			if (fm1 != null)
			{
				fm1.setAmount(fm.getAmount());
				fm1.setBranch(fm.getBranch());
				fm1.setDebitCredit(fm.getDebitCredit());
				fm1.setAuthorisor(fm.getAuthorisor());
			}

			// has any message been added?
			if (!added && fm1 != null)
			{
				added = true;
			}
		}

		return added;
	}

	/**
	 * Check if the message already exists in the list
	 * 
	 * @param scrnNo
	 *            - the screen number where the message has been generated
	 * @param fieldName
	 *            - the field name that causes the message to be generated
	 * @param eqMessage
	 *            - the message
	 * @param messageText
	 *            - the message in 37 character format
	 * 
	 * @return true - if the message does not exists
	 */
	public boolean chkMessageExists(int screenSetId, int scrnNo, String fieldName, int sequence, String messageText)
	{
		FunctionMessage fm;
		for (int i = 0; i < messages.size(); i++)
		{
			fm = messages.get(i);
			if (fm.getScreenSetId() == screenSetId && fm.getScrnNo() == scrnNo && fm.getFieldName().equals(fieldName)
							&& fm.getSequence() == sequence && fm.getEqMessage().getDsepms().equals(messageText))
			{
				return true;
			}
		}

		// not found
		return false;
	}

	/**
	 * Convert the function messages to an XML
	 * 
	 * @return the equivalent XML of the function messages
	 * 
	 * @throws EQException
	 */
	public String cvtToXML() throws EQException
	{
		EqBeanFactory eqBeanFactory = EqBeanFactory.getEqBeanFactory();
		String xml = eqBeanFactory.serialiseBeanAsXML(this);
		return xml;
	}

	/**
	 * Convert to String
	 * 
	 * @return the string representation
	 */
	@Override
	public String toString()
	{
		StringBuffer buffer = new StringBuffer();

		for (int i = 0; i < messages.size(); i++)
		{
			buffer.append(messages.get(i) + "\n");
		}

		return buffer.toString();
	}

	/**
	 * Return the list of messages in DSEPMS (maximum of 20)
	 * 
	 * @return the list of messages in DSEPMS (maximum of 20)
	 */
	public String rtvMessageIds()
	{
		StringBuffer buffer = new StringBuffer();

		// maximum of 20 only
		int length = messages.size();
		if (length > 20)
		{
			length = 20;
		}

		for (int i = 0; i < length; i++)
		{
			String value = Toolbox.trim(Toolbox.pad(messages.get(i).getEqMessage().getDsepms(), 37), 37);
			buffer.append(value);
		}
		return buffer.toString();
	}

	/**
	 * Return the list of amounts associated with the message (maximum of 20)
	 * 
	 * @return the list of amounts associated with the message (maximum of 20)
	 */
	public String rtvAmounts()
	{
		StringBuffer buffer = new StringBuffer();

		// maximum of 20 only
		int length = messages.size();
		if (length > 20)
		{
			length = 20;
		}

		for (int i = 0; i < length; i++)
		{
			String value = Toolbox.trim(Toolbox.padAtFront(messages.get(i).getAmount(), "0", 15), 15);
			buffer.append(value);
		}
		return buffer.toString();
	}

	/**
	 * Return the list of branches associated with the message (maximum of 20)
	 * 
	 * @return the list of branches associated with the message (maximum of 20)
	 */
	public String rtvBranches()
	{
		StringBuffer buffer = new StringBuffer();

		// maximum of 20 only
		int length = messages.size();
		if (length > 20)
		{
			length = 20;
		}

		for (int i = 0; i < length; i++)
		{
			String value = Toolbox.trim(Toolbox.pad(messages.get(i).getBranch(), 4), 4);
			buffer.append(value);
		}
		return buffer.toString();
	}

	/**
	 * Return the list of DR/CR flag associated with the message (maximum of 20)
	 * 
	 * @return the list of DR/CR flag associated with the message (maximum of 20)
	 */
	public String rtvDrCr()
	{
		StringBuffer buffer = new StringBuffer();

		// maximum of 20 only
		int length = messages.size();
		if (length > 20)
		{
			length = 20;
		}

		for (int i = 0; i < length; i++)
		{
			String value = Toolbox.trim(Toolbox.pad(messages.get(i).getDebitCredit(), 1), 1);
			buffer.append(value);
		}
		return buffer.toString();
	}

	/**
	 * Return the list of messages in EQMesage format
	 * 
	 * @return the list of messages in EQMesage format
	 */
	public List<EQMessage> rtvMessages()
	{
		ArrayList<EQMessage> eqMsg = new ArrayList<EQMessage>();

		for (int i = 0; i < messages.size(); i++)
		{
			eqMsg.add(messages.get(i).getEqMessage());
		}
		return eqMsg;
	}

	/**
	 * Return the list of messages
	 * 
	 * @return the list of messages
	 */
	public String[] rtvMessagesAsStringArray()
	{
		String[] msgs = new String[messages.size()];

		for (int i = 0; i < messages.size(); i++)
		{
			String message = messages.get(i).rtvFormattedText();
			msgs[i] = message;
		}

		return msgs;
	}

	/**
	 * Populates the allFunctionMessages property using the messages from FunctionMessage.
	 */
	public void populateAllFunctionMessages()
	{
		this.allFunctionMessages = null;
		allFunctionMessages = new TreeMap<String, FunctionMessage>();

		if (!messages.isEmpty())
		{
			this.populateAllFunctionMessagesInternal(this.messages);
		}
	}

	/**
	 * Populates the allFunctionMessages property from the content of anyMessages. Population rule: (1) Comma delimited fields in a
	 * field name are split and used as individual keys for the same FunctionMessage object. (2) A RepeatingField FunctionMessage
	 * key is appended with underscore and sequence number. (3)If a field has more than one message, the FunctionMessage of greater
	 * severity is retained.
	 * 
	 * @param anyMessages
	 *            - list of messages
	 */
	private void populateAllFunctionMessagesInternal(List<FunctionMessage> anyMessages)
	{
		if (anyMessages != null && !anyMessages.isEmpty())
		{
			Iterator<FunctionMessage> messageIterator = anyMessages.iterator();

			while (messageIterator.hasNext())
			{
				FunctionMessage message = messageIterator.next();
				String fieldNameKey = null;
				RelatedFields relatedFields = new RelatedFields(message.getFieldName());
				if (relatedFields.getArrRelatedFields().length > 0)
				{
					for (String fieldName : relatedFields.getArrRelatedFields())
					{
						// avoid overwrite of FunctionMessage in map if its severity is greater than that of this
						// FunctionMessage being processed
						if (isMessageExists(fieldName) && getFunctionMessage(fieldName).rtvMsgSev() > message.rtvMsgSev())
						{
							continue;
						}

						// for repeating field
						if (message.getSequence() > 0)
						{
							fieldNameKey = getRepeatingDataField(fieldName, message.getSequence());
						}
						// for normal field
						else
						{
							fieldNameKey = fieldName;
						}

						allFunctionMessages.put(fieldNameKey, message);
					}
				}
				else
				{
					// avoid overwrite of FunctionMessage in map if its severity is greater than that of this
					// FunctionMessage being processed
					if (isMessageExists(message.getFieldName())
									&& getFunctionMessage(message.getFieldName()).rtvMsgSev() > message.rtvMsgSev())
					{
						continue;
					}

					// for repeating field
					if (message.getSequence() > 0)
					{
						fieldNameKey = getRepeatingDataField(message.getFieldName(), message.getSequence());
					}
					// for normal field
					else
					{
						fieldNameKey = message.getFieldName();
					}

					allFunctionMessages.put(fieldNameKey, message);
				}
			}
		}
	}

	/**
	 * Determines if there is an existing FunctionMessage having this fieldName. This method will return true if the message exist
	 * and false if it doesn't.
	 * 
	 * @param fieldName
	 *            - the name of the field
	 * 
	 * @return boolean
	 */
	public boolean isMessageExists(String fieldName)
	{
		return (allFunctionMessages != null && !allFunctionMessages.isEmpty() && allFunctionMessages.containsKey(fieldName));
	}

	/**
	 * Returns the FunctionMessage keyed by fieldName
	 * 
	 * @param fieldName
	 *            - the name of the field
	 * 
	 * @return FunctionMessage
	 */
	public FunctionMessage getFunctionMessage(String fieldName)
	{
		if (this.isMessageExists(fieldName))
		{
			return allFunctionMessages.get(fieldName);
		}
		else
		{
			return null;
		}
	}

	/**
	 * Returns the FunctionMessage if it exists for a RepeatingField
	 * 
	 * @param fieldName
	 *            - the name of the field
	 * 
	 * @param row
	 *            - row number of the Repeating Field Data
	 * 
	 * @return FunctionMessage
	 */
	public FunctionMessage getFunctionMessage(String fieldName, int row)
	{
		String fieldNameKey = getRepeatingDataField(fieldName, row);
		if (this.isMessageExists(fieldNameKey))
		{
			return allFunctionMessages.get(fieldNameKey);
		}
		else
		{
			return null;
		}
	}

	/**
	 * Returns the concatenated representative string FieldName for a Repeating Field
	 * 
	 * @param fieldName
	 *            - the name of the field
	 * 
	 * @param row
	 *            - row number of the Repeating Field Data
	 * 
	 * @return String
	 */
	private String getRepeatingDataField(String fieldName, int row)
	{
		return fieldName + "_" + row;
	}

	/**
	 * Search a KSM
	 * 
	 * @param ksmId
	 *            - the KSM id
	 * @param startIndex
	 *            - the index to start searching from the list
	 * 
	 * @return the index of the first message with this message id
	 */
	public int search(String ksmId, int startIndex)
	{
		for (int i = startIndex; i < messages.size(); i++)
		{
			FunctionMessage fm = messages.get(i);
			if (fm.getEqMessage().getMessageID().equals(ksmId))
			{
				return i;
			}
		}
		return -1;
	}

	/**
	 * Search an KSM
	 * 
	 * @param ksmId
	 *            - the KSM id
	 * 
	 * @return the index of the first message with this message id
	 */
	public int search(String ksmId)
	{
		return search(ksmId, 0);
	}

}
